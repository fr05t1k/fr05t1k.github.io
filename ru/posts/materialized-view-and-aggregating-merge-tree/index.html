<!DOCTYPE html>
<html lang="ru">
<head>
  
    <title>Как оптимизировать агрегированные запросы в Clickhouse? :: /etc/notes — Персональный блор о разработке програмного обеспечения</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="description" content="Overview Clickhouse достаточно быстрое хранилище, но когда ваше хранилище перерастает тот момент, когда агрегированные запросы по сырым данным выполняются медленно. В этот момент мы начинаем задумываться об оптимизации. Сегодня я хочу рассказать о подходе где мы будем использоваться AggregatingMergeTree. Materialized View получает все данные по определенному запросу который вы указываете при создании и AggregatingMergeTree агрегирует эти данные по ключу сортировки. Используя этот подход, мы можем группировать данные по определенным полям и это позволит делать тяжелые запросы по большому промежутку времени."/>
<meta name="keywords" content="software, компютерные науки, программирование, блог, разработка, инженерия, исходный код"/>
<meta name="robots" content="noodp"/>
<link rel="canonical" href="https://etcnotes.com/ru/posts/materialized-view-and-aggregating-merge-tree/" />


<link rel="stylesheet" href="https://etcnotes.com/assets/style.css">


<link rel="stylesheet" href="https://etcnotes.com/style.css">


<link rel="shortcut icon" href="/img/favicon.png">
<link rel="apple-touch-icon-precomposed" sizes="76x76" href="/img/icon_76pt.png">
<link rel="icon" type="image/png" href="/img/icon_76pt.png" sizes="76x76">
<link rel="icon" type="image/png" href="/img/icon_40pt.png" sizes="40x40">
<link rel="icon" type="image/png" href="/img/icon_29pt.png" sizes="29x29">
<link rel="icon" type="image/png" href="/img/icon_20pt.png" sizes="20x20">



<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="Как оптимизировать агрегированные запросы в Clickhouse? :: /etc/notes — Персональный блор о разработке програмного обеспечения" />
<meta name="twitter:description" content="Overview Clickhouse достаточно быстрое хранилище, но когда ваше хранилище перерастает тот момент, когда агрегированные запросы по сырым данным выполняются медленно. В этот момент мы начинаем задумываться об оптимизации. Сегодня я хочу рассказать о подходе где мы будем использоваться AggregatingMergeTree. Materialized View получает все данные по определенному запросу который вы указываете при создании и AggregatingMergeTree агрегирует эти данные по ключу сортировки. Используя этот подход, мы можем группировать данные по определенным полям и это позволит делать тяжелые запросы по большому промежутку времени." />
<meta name="twitter:site" content="https://etcnotes.com/" />
<meta name="twitter:creator" content="" />
<meta name="twitter:image" content="https://etcnotes.com/img/merge-tree.png">


<meta property="og:locale" content="ru" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Как оптимизировать агрегированные запросы в Clickhouse? :: /etc/notes — Персональный блор о разработке програмного обеспечения">
<meta property="og:description" content="Overview Clickhouse достаточно быстрое хранилище, но когда ваше хранилище перерастает тот момент, когда агрегированные запросы по сырым данным выполняются медленно. В этот момент мы начинаем задумываться об оптимизации. Сегодня я хочу рассказать о подходе где мы будем использоваться AggregatingMergeTree. Materialized View получает все данные по определенному запросу который вы указываете при создании и AggregatingMergeTree агрегирует эти данные по ключу сортировки. Используя этот подход, мы можем группировать данные по определенным полям и это позволит делать тяжелые запросы по большому промежутку времени." />
<meta property="og:url" content="https://etcnotes.com/ru/posts/materialized-view-and-aggregating-merge-tree/" />
<meta property="og:site_name" content="Как оптимизировать агрегированные запросы в Clickhouse?" />
<meta property="og:image" content="https://etcnotes.com/img/merge-tree.png">
<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">

<meta property="article:published_time" content="2019-04-24 00:00:00 &#43;0300 EEST" />







</head>
<body class="dark-theme">
<div class="container">
  <header class="header">
  <span class="header__inner">
    <a href="/ru" class="logo" style="text-decoration: none;">
  
    <span class="logo__mark"><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" width="44" height="44" viewBox="0 0 44 44">
  <polyline fill="none" stroke="#000" stroke-width="2" points="15 8 29.729 22.382 15 35.367"/>
</svg>
</span>
    <span class="logo__text">/etc/notes</span>
    <span class="logo__cursor"></span>
  
</a>

    <span class="header__right">
      
        <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="/ru">Блог</a></li>
        
      
        
          <li><a href="/ru/about">Обо мне</a></li>
        
      
        
          <li><a href="/">English</a></li>
        
      
    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/ru">Блог</a></li>
      
    
      
        <li><a href="/ru/about">Обо мне</a></li>
      
    
      
        <li><a href="/">English</a></li>
      
    
  </ul>
</nav>

        <span class="menu-trigger">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M0 0h24v24H0z" fill="none"/>
            <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
          </svg>
        </span>
      
      <span class="theme-toggle">
        <svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
  3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
  13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"/>
</svg>

      </span>
    </span>
  </span>
</header>


  <div class="content">
    
  <div class="post">
    <h2 class="post-title"><a href="https://etcnotes.com/ru/posts/materialized-view-and-aggregating-merge-tree/">Как оптимизировать агрегированные запросы в Clickhouse?</a></h2>
    <div class="post-meta">
      
        <span class="post-date">
            2019-04-24
        </span>
      
      
    </div>

    
      <span class="post-tags">
        
          #<a href="https://etcnotes.com/tags/howto">howto</a>&nbsp;
        
          #<a href="https://etcnotes.com/tags/doc">doc</a>&nbsp;
        
      </span>
    

    
      <img src="https://etcnotes.com/img/merge-tree.png" class="post-cover" />
    

    
      <div class="table-content">
        <h1>Содержание</h1>
        <nav id="TableOfContents">
<ul>
<li><a href="#overview">Overview</a></li>
<li><a href="#как">Как</a>
<ul>
<li><a href="#комбинаторы-агрегатных-функций">Комбинаторы агрегатных функций</a></li>
</ul></li>
<li><a href="#наполнение">Наполнение</a></li>
<li><a href="#итоги">Итоги</a></li>
</ul>
</nav>
      </div>
    

    <div class="post-content">
      

<h1 id="overview">Overview</h1>

<p>Clickhouse достаточно быстрое хранилище, но когда ваше хранилище перерастает тот момент, когда агрегированные запросы
по сырым данным выполняются медленно. В этот момент мы начинаем задумываться об оптимизации. Сегодня я хочу рассказать
о подходе где мы будем использоваться <a href="https://clickhouse.yandex/docs/en/operations/table_engines/aggregatingmergetree/">AggregatingMergeTree</a>.
<em>Materialized View</em> получает все данные по определенному запросу который вы указываете при создании и <em>AggregatingMergeTree</em>
агрегирует эти данные по <em>ключу сортировки</em>. Используя этот подход, мы можем группировать данные по определенным полям и
это позволит делать тяжелые запросы по большому промежутку времени. Важно, коэффициент оптимизации является отношением
всех записей к уникальным записям получившимися в materialized view. Это говорит на сколько эфиктивна будет оптимизация.</p>

<h1 id="как">Как</h1>

<pre><code class="language-sql">CREATE TABLE views
(
  id                UInt64,
  manager           UInt64,
  splitTest         UInt64,
  splitTestOption   UInt64,
  client            UInt64,
  schemeType        UInt64,
  campaign          UInt64,
  creative          UInt64,
  source            UInt64,
  domain            UInt64,
  referrer          UInt64,
  country           String,
  device            String,
  os                String,
  viewAt            DateTime,
  viewDate          Date DEFAULT toDate(viewAt),
  platform          UInt64,
  orientation       UInt64,
  pageType          UInt64,
  categoryName      UInt64,
  widgetName        UInt64,
  widgetElement     UInt64,
  logged            UInt8,
  isVisited         UInt8
) ENGINE = ReplicatedMergeTree('/clickhouse/tables/test/{shard}/views', '{replica}', viewDate,
           (viewDate, client), 8192);
</code></pre>

<p>У нас имеется большая таблица которую мы собираемся оптимизировать по полям <em>viewDate, manager, client, campaign,
creative, source, country, device, domain</em>. Нам нужно создать <em>Materialized view</em> c движком <em>AggregatingMergeTree</em>.</p>

<pre><code class="language-sql">CREATE MATERIALIZED VIEW views_mat
  engine = AggregatingMergeTree partition by viewDate order by (
    viewDate,
    manager,
    client,
    campaign,
    creative,
    source,
    country,
    device,
    domain,
    landing)
AS
SELECT viewDate,
       manager,
       client,
       campaign,
       creative,
       source,
       country,
       device,
       domainId,
       landing,
       countState() as amount
FROM views
GROUP BY viewDate,
         manager,
         client,
         campaign,
         creative,
         source,
         country,
         device,
         domain,
         landing
</code></pre>

<h2 id="комбинаторы-агрегатных-функций">Комбинаторы агрегатных функций</h2>

<p>Вы можете заметить функцию <em>countState()</em>. Она не возвращает готовый результат, а возвращает промежуточное состояние
агрегатной функции. Вам нужно использовать _<em>countMerge()</em> для получения результата. Более подробно о комбинаторах
можно прочитать из (документации)[<a href="https://clickhouse.yandex/docs/en/query_language/agg_functions/combinators/">https://clickhouse.yandex/docs/en/query_language/agg_functions/combinators/</a>].</p>

<p>Сделаем запрос и посмотрим разницу между сырыми и агрегированными данными.</p>

<p>Сырые:</p>

<pre><code class="language-sql">SELECT
    campaign,
    count() AS views
FROM views
WHERE (client IN 7559922) AND (country IN 'in') AND ((viewDate &gt;= '2018-06-01') AND (viewDate &lt;= '2018-12-30'))
GROUP BY campaign;

Row 1:
──────
campaignId:  0
impressions: 7955062

Row 2:
──────
campaignId:  812661
impressions: 11003

Row 3:
──────
campaignId:  1334
impressions: 253350

Row 4:
──────
campaignId:  569467
impressions: 93182604

Row 5:
──────
campaignId:  237410
impressions: 7554

Row 6:
──────
campaignId:  23456
impressions: 3

Row 7:
──────
campaignId:  524556
impressions: 438

7 rows in set. Elapsed: 46.781 sec. Processed 9.18 billion rows, 116.92 GB (196.24 million rows/s., 2.50 GB/s.)
</code></pre>

<p>Агрегированные:</p>

<pre><code class="language-sql">SELECT
    campaignId,
    countMerge(amount) AS impressions
FROM impressions_mat
WHERE (userId IN 26) AND (country IN 'in') AND ((impressionDate &gt;= '2018-06-01') AND (impressionDate &lt;= '2018-12-30'))
GROUP BY campaignId

Row 1:
──────
campaignId:  0
impressions: 7955062

Row 2:
──────
campaignId:  812661
impressions: 11003

Row 3:
──────
campaignId:  1334
impressions: 253350

Row 4:
──────
campaignId:  569467
impressions: 93182604

Row 5:
──────
campaignId:  237410
impressions: 7554

Row 6:
──────
campaignId:  23456
impressions: 3

Row 7:
──────
campaignId:  524556
impressions: 438

7 rows in set. Elapsed: 0.116 sec. Processed 9.13 million rows, 448.10 MB (78.78 million rows/s., 3.86 GB/s.)
</code></pre>

<p>На другие запросах оптимизация может быть лучше или хуже.</p>

<h1 id="наполнение">Наполнение</h1>

<p><em>CREATE MATERIALIZED VIEW</em> имеет опцию <em>POPULATE</em>. Она позволяет наполнить таблицу с данными из запроса, но есть и
подводный камень. Отображение не получит данные которые появились в период наполнения. Таким образом, мы создаем
отображение и наполняем его после создания. В нашем случае, мы останавливаем вставку данные, наполняем и запускаем
вставку.</p>

<h1 id="итоги">Итоги</h1>

<p>Если вам нужно оптимизировать определенные запросы вы можете использовать материализованное представление с агрегированным
запросом. Имейте в виду, улучшение скорости пропорционально количеству уникальных строк в вашей исходной таблице.</p>

    </div>
    
      <div class="pagination">
        <div class="pagination__title">
          <span class="pagination__title-h">Читать другие статьи</span>
          <hr />
        </div>
        <div class="pagination__buttons">
          
            <span class="button previous">
              <a href="https://etcnotes.com/ru/posts/mysql2csv/">
                <span class="button__icon">←</span>
                <span class="button__text">Вывод MySQL client как CSV</span>
              </a>
            </span>
          
          
            <span class="button next">
              <a href="https://etcnotes.com/ru/posts/sstable-and-lsm/">
                <span class="button__text">SSTable и LSM-деревья. Как хранить ключ-значение на диске?</span>
                <span class="button__icon">→</span>
              </a>
            </span>
          
        </div>
      </div>
    
    
      <div class="comments">
        <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "etcnotes" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
      </div>
    
  </div>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright copyright--user"><a href="https://creativecommons.org/licenses/by-nc-nd/3.0/">Все права защищены</a>, 2019</div>
    
  </div>
</footer>

<script src="https://etcnotes.com/assets/main.js"></script>
<script src="https://etcnotes.com/assets/prism.js"></script>

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-132816408-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-132816408-1');
</script>


  
</div>

</body>
</html>
